"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const json_schema_to_typescript_1 = require("json-schema-to-typescript");
const lodash_1 = require("lodash");
const schema_collection_1 = require("../schema-collection");
const pascal_case_1 = require("../utils/pascal-case");
exports.generateTypescript = async (schemaMap) => {
    const schemaCollection = schema_collection_1.SchemaCollection(schemaMap);
    const { entityTitles, enumTitles } = schemaCollection;
    const interfaces = await Promise.all(entityTitles.map(title => generateSchemaInterface(title, schemaCollection)));
    interfaces.push(generateEntityModelType(entityTitles, schemaCollection));
    interfaces.push(generateMongooseInterface(entityTitles));
    const enums = generateEnums(enumTitles, schemaCollection);
    const typescriptFiles = {
        interfaces, enums
    };
    return typescriptFiles;
};
const generateSchemaInterface = async (title, schemaCollection) => {
    const filename = lodash_1.kebabCase(title) + '.ts';
    const interfaceSchema = schemaCollection.interfaceSchema(title);
    const interfaceName = interfaceSchema.title;
    const contents = await json_schema_to_typescript_1.compile(interfaceSchema, interfaceName, {
        style: {
            semi: false
        }
    });
    return { filename, contents };
};
const generateEnum = (name, map) => `
/**
 * This file was automatically generated by generate-typescript
 * DO NOT MODIFY IT BY HAND
 */

export enum ${name} {
${Object.keys(map).map(key => `  ${key} = "${map[key]}"`).join(',\n')}
}

export const ${name}Map = {
${Object.keys(map).map(key => `  "${key}": "${map[key]}"`).join(',\n')},
${Object.keys(map).map(key => `  "${map[key]}": "${key}"`).join(',\n')}
}
`.trimLeft();
const generateEnums = (enumTitles, schemaCollection) => {
    const enums = [];
    enumTitles.forEach(title => {
        const enumSchema = schemaCollection.get(title);
        const keys = enumSchema.enum;
        const titles = enumSchema._enumTitles;
        if (keys.length !== titles.length) {
            throw Error('Enum - enum.length must be the same as _enumTitles.length');
        }
        const keyToTitleMap = keys.reduce((map, key, i) => {
            map[key] = titles[i];
            return map;
        }, {});
        const filename = lodash_1.kebabCase(title) + '.ts';
        const contents = generateEnum(pascal_case_1.pascalCase(title), keyToTitleMap);
        enums.push({ filename, contents });
    });
    return enums;
};
const generateEntityModelType = (titles, schemaCollection) => {
    const filename = 'entity-model.ts';
    const contents = entityTitlesToModelType(titles, schemaCollection);
    return { filename, contents };
};
const generateMongooseInterface = (titles) => {
    const filename = 'mongoose-models.ts';
    const contents = entityTitlesToInterface(titles);
    return { filename, contents };
};
const entityTitleToInterfaceDefinition = title => {
    const ctorName = pascal_case_1.pascalCase(title);
    return `  ${ctorName}: IMongooseEntityModel`;
};
const entityTitlesToInterface = titles => {
    return `
/**
 * This file was automatically generated by generate-typescript
 * DO NOT MODIFY IT BY HAND
 */
import * as mongoose from 'mongoose'

export interface IMongooseEntityModel extends mongoose.Model<mongoose.Document> {
  uniquePropertyNames: () => string[],
  valuesForUniqueProperty: ( propertyName: string, parentId?: string ) => Promise<string[]>
  uniqueValuesMap: ( parentId?: string ) => Promise<{ [ propertyName: string ]: string[] }>
}

export interface IMongooseModels {
${titles.map(entityTitleToInterfaceDefinition).join('\n')}
}
`.trimLeft();
};
const entityTitleToImport = (title, schemaCollection) => {
    const filename = lodash_1.kebabCase(title);
    const interfaceSchema = schemaCollection.interfaceSchema(title);
    const interfaceName = interfaceSchema.title;
    return `import { ${interfaceName} } from './${filename}'`;
};
const entityTitlesToUnionType = (titles, schemaCollection) => {
    return titles.map(title => {
        const interfaceSchema = schemaCollection.interfaceSchema(title);
        const interfaceName = interfaceSchema.title;
        return interfaceName;
    }).join(' | ');
};
const entityTitlesToModelType = (titles, schemaCollection) => {
    return `
/**
 * This file was automatically generated by generate-typescript
 * DO NOT MODIFY IT BY HAND
 */
${titles.map(title => entityTitleToImport(title, schemaCollection)).join('\n')}

export type EntityModel = ${entityTitlesToUnionType(titles, schemaCollection)}
`.trimLeft();
};
//# sourceMappingURL=generate-typescript.js.map